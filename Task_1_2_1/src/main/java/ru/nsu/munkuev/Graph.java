package ru.nsu.munkuev;

import java.util.List;
import java.util.ArrayList;
import java.util.Collections;


/**
 * Интерфейс ориентированного графа.
 *
 * <h2>Общая модель</h2>
 * <ul>
 *     <li>Граф ориентированный, без параллельных рёбер и петель (по смыслу реализаций).</li>
 *     <li>Вершины хранятся в списке {@link #getVertices()}, индекс в списке совпадает с {@link Vertex#getId()}.</li>
 *     <li>Все методы, принимающие вершину по числовому id, ожидают id в диапазоне {@code [0, getVertices().size())}.</li>
 * </ul>
 *
 * <h2>Для разработчиков: как добавить новую реализацию графа</h2>
 * <ol>
 *     <li>Создайте класс, реализующий {@code Graph} (например, {@code MyFancyGraph}).</li>
 *     <li>Выберите внутреннее представление (матрица смежности, списки смежности, матрица инцидентности и т.п.).</li>
 *     <li>Гарантируйте инвариант:
 *         <ul>
 *             <li>Список вершин не содержит {@code null}.</li>
 *             <li>{@link Vertex#getId()} для i-й вершины всегда равен i.</li>
 *             <li>Все методы корректно обновляют и структуру рёбер, и id вершин при добавлении/удалении.</li>
 *         </ul>
 *     </li>
 *     <li>Реализуйте методы:
 *         <ul>
 *             <li>{@link #addVertex(Vertex)} / {@link #removeVertex(Vertex)} — добавление и удаление вершин;</li>
 *             <li>{@link #addEdge(int, int)} / {@link #removeEdge(int, int)} — добавление и удаление рёбер;</li>
 *             <li>{@link #getParents(int)} / {@link #getChildren(int)} — доступ к структуре графа;</li>
 *             <li>{@link #getVertices()} — доступ к вершинам.</li>
 *         </ul>
 *     </li>
 *     <li>Для корректной работы с существующими тестами:
 *         <ul>
 *             <li>Для некорректных индексов в {@code addEdge/removeEdge} возвращайте {@code false} (не бросайте исключения).</li>
 *             <li>Для некорректных индексов в {@code getParents/getChildren} логично бросать {@link IllegalArgumentException}.</li>
 *         </ul>
 *     </li>
 * </ol>
 *
 * <h2>Интеграция с существующими реализациями</h2>
 * <p>
 * Все текущие реализации ({@link AdjacencyMatrixGraph}, {@link AdjacencyListGraph}, {@link IncidenceMatrixGraph})
 * используют <b>структурное равенство</b>:
 * два графа равны, если у них совпадает количество вершин и для каждой вершины совпадает отсортированный список детей.
 * </p>
 *
 * <ul>
 *     <li>Метод {@link #equals(Object)} в конкретных классах должен придерживаться <i>той же</i> идеи.</li>
 *     <li>Метод {@link #hashCode()} по умолчанию реализован в интерфейсе и опирается на структуру детей каждой вершины.
 *         Если вы переопределяете {@code equals} с другой логикой, <b>обязательно</b> переопределите и {@code hashCode} так,
 *         чтобы он был совместим с вашим {@code equals}.</li>
 * </ul>
 *
 * <h2>Для пользователей: какие графы есть и как их выбирать</h2>
 * <p>Доступны три реализации:</p>
 * <ul>
 *     <li>{@link AdjacencyMatrixGraph} — граф на матрице смежности.
 *         <ul>
 *             <li>Плюсы: O(1) проверка наличия ребра, простая реализация.</li>
 *             <li>Минусы: потребление памяти O(n²), для разреженных графов может быть тяжело.</li>
 *             <li>Рекомендуется для плотных графов и небольшого числа вершин.</li>
 *         </ul>
 *     </li>
 *     <li>{@link AdjacencyListGraph} — граф на списках смежности.
 *         <ul>
 *             <li>Плюсы: память O(n + m), хорошо подходит для разреженных графов.</li>
 *             <li>Минусы: проверка наличия ребра O(deg(v)), чуть сложнее реализация.</li>
 *             <li>Рекомендуется как «дефолтный» вариант для большинства задач.</li>
 *         </ul>
 *     </li>
 *     <li>{@link IncidenceMatrixGraph} — граф на матрице инцидентности (вершины × рёбра).
 *         <ul>
 *             <li>Плюсы: удобно для алгоритмов, которые активно работают с рёбрами, их удалением/фильтрацией.</li>
 *             <li>Минусы: более сложное представление, дополнительная память на столбцы-рёбра.</li>
 *             <li>Рекомендуется, если алгоритм естественно формулируется в терминах рёбер и их инцидентности.</li>
 *         </ul>
 *     </li>
 * </ul>
 *
 * <p>
 * Пользователь выбирает реализацию в зависимости от:
 * </p>
 * <ul>
 *     <li>размера графа и плотности рёбер,</li>
 *     <li>частоты операций добавления/удаления,</li>
 *     <li>того, важнее ли быстрый доступ по рёбрам или экономия памяти.</li>
 * </ul>
 */
public interface Graph {
    /**
     * Добавляет вершину в текущий граф.
     * @param vertex добавляемая вершина
     * @return результат добавления вершины
     * @throws IllegalArgumentException если передана некорректная вершина
     */
     boolean addVertex(Vertex vertex);

     /**
     * Удаляет вершину из текущего графа.
     * @param vertex удаляемая вершина
     * @return результат удаления вершины
     * @throws IllegalArgumentException если передана некорректная вершина
     */
     boolean removeVertex(Vertex vertex);

    /**
     * Добавляет ребро в текущий граф.
     * @param from начало ребра
     * @param to конец ребра
     * @return результат добавления ребра
     * @throws IllegalArgumentException если переданы некорректное начало или конец ребра
     */
     boolean addEdge(int from, int to);

     /**
     * Удаляет ребро из текущего графа.
     * @param from начало ребра
     * @param to конец ребра
     * @return результат удаления ребра
     * @throws IllegalArgumentException если переданы некорректное начало или конец ребра
     */
     boolean removeEdge(int from, int to);

    /**
     * Возвращает список всех вершин текущего графа.
     * @return список вершин графа
     */
     List<Vertex> getVertices();

    /**
     * Возвращает список родителей конкретной вершины в текущем графе.
     * @param vertex вершина, родителей которой надо узнать
     * @return список родителей
     */
     List<Integer> getParents(int vertex);

    /**
     * Возвращает список потомков конкретной вершины в текущем графе.
     * @param vertex вершина, потомков которой надо узнать
     * @return список потомков
     */
     List<Integer> getChildren(int vertex);

     @Override
     boolean equals(Object o);


     /**
      * Структурный {@code hashCode} графа.
      * <p>
      * Использует количество вершин и отсортированные списки детей для каждой вершины,
      * поэтому для любых двух графов, равных с точки зрения {@link #equals(Object)}, хеш-код совпадает.
      *
      * @return хеш-код, совместимый с {@link #equals(Object)}
      */
     @Override
     int hashCode();
}
